Create virtual environments to allow for different versions of the same project to be created, isolated from other project environments.
--> In terminal 'py -3 -m venv venv' to create a virtual environment called 'venv'
--> then make sure terminal is also using virtual env by connecting it to the activate.bat file in the venv folder 'venv\Scripts\activate.bat'

FastAPI is a modern, fast (high-performance), web framework for building APIs with Python 
uvicorn is a lightning-fast ASGI (async server gateway interface) server implementation, using uvloop and httptools. Supports async processing (efficiently handle multiple req concurrently); HTTP + Websockets (handle http + real-time 2-way traffic); enables interloperability between different frameworks and servers.
*FastAPI --> Autogenerates API documentation (2 ways to access: /docs or /redoc)


'decorator' is a design pattern in Python that allows adding new functionality to an existing object without modifying its structure. Functions are objects - in this scenario the 'app' object (FastAPI function) is wrapping the function for the route function. You can create functions and the use them as 'decorator' variables with the @ symbol to wrap/nest other functions and add/chain functionality to them.
You can add default status code to after route + use status.HTTP_###_action from fastapi responses module

TERMINAL [ uvicorn main:app --reload ] to start webserver (main = filename, app = FastAPI object name, --reeload = auto-reload server on file changes [dev env])

*The order of the route functions is important as FastAPI will match the first route function that matches the URL path. So if you have a route function that is more general and a route function that is more specific, the more specific route function should be placed first in the code.

Pydantic - Why Schema needed: 
Difficult to get valueswor from req body without knowing structure of data beforehand
Client can send whatever data they want
Data isnt getting validated.
Force client to send data in a standardised, specific format/schema that we expect.
APIs should be designed like this --> explicitly define what the data should look like so FE devs know what to send and BE devs know what to expect.
Pydantic models have methods that can be used on them eg. dict() to convert to dictionary, json() to convert to json, etc.

DATABASES:
Don't work or interact with DB directly --> use software DBMS to interact and send result back
For this project --> using PostgreSQL
Each instance of Postgres can be carved into into multiple separate/isolated DB
Postgres requires user to specify which DB to connect to 
pgAdmin = GUI tool to manage Postgres DBs
UNIQUE and NULL/NOT NULL --> eg. column constraints

--> *psycopg* is adapter for Python that allows interaction with Postgres DBs
https://www.psycopg.org/psycopg3/docs/basic/usage.html
Use psycopg db control structure --> cursor  to perform DB operations (execute queries, fetch results, etc) that can be added to route handling logic
!SQL injection attack - don't use f-strings for variables use %s + SQL library offers functionality to sanitise endpoints
need to commit staged changes --> when adding to DB (conn.commit())

For Python Apps(+other languages)  - Different ways to interact with DB
- example so far was using default Postgres driver/adaptor to send raw SQL commands to the DB
*--> A Popular method ORM (Object Relational Mapping) uses a layer of abstractions between code and DB so you can use Python code/objects/features to perform all DB ops (no SQL) [i.e. interact with ORM, which basically uses the drivers you would have employed if you were writing raw SQL, that will convert Python code to SQL commands] 
[SQLAlchemy very popular] - WHAT CAN YOU DO WITH ORMs (key features):
Instead of manually defining tables in postgres - define tables as Python classes/models
Query in Python code (no SQL necessary), chaining methods.
class Post(Base):
	__tablename__ = 'posts'
	id = Column(Integer, primary_key=True, index=True)
	title = Column(String, index=True, nullable=False)
	content = Column(String, nullable=False)
	published = Column(Boolean, default=False)

db.query(models.Post).filter(models.Post.id = id).first()

**to handle DB connect when using SQLAlchemy ORM, we need to create a database.py file in the app directory
-->installed SQLAlchemy and import required components to create DB and start session

*SQLAlchemy has the code to write Python (eg. define models) but doesn't 'actually know how to talk to the DB' ----> so need DB Driver (eg. psycopg)
*NOTE - when creating table from models - if table already exists no new table will be created - so if you modify table model you need to drop the table and recreate it
---> Normally use 'Alembiuc' to handle this - a migration tool that can initiailise dbs, handle changes to DB schema

DIFFERENCE BETWEEN Schema and Pydantic Model (WE NEED BOTH MODELS):
Pydantic (library) model --> BaseModel referred to as schema.  Define structure of req/res data. Validates structure and data types for fields + convert to/from JSON.
SQLAlchemy (library) model --> ORM Base model. Define columns/attributes + data types of DB tables. Used to interact (CRUD) with DB.
--> To use Res Models need to add response_model param to route function @app.method('/route', response_model=ModelName) - FastAPI will validate and convert response data to model schema 
(note for get all post need to use List[ModelName] as response_model + import List from typing module)

FastAPI dependencies are functions that run before the route function is executed. They can be used to perform operations that are common to multiple route functions (eg. DB connection, authentication, etc). They can also be used to validate data before it is passed to the route function.

HANDLING USER REGISTRATION:
need to create model for user registration data (Pydantic model) + model for user data in DB (SQLAlchemy model)

hashing user password --> install passlib package + Bcrypt library (hashing algorithm)

# GET USER (by id) - can be used as part of auth process
# depending on how FE is set up eg. when using JWT (sent as cookies so won't know you are logged in) so APIs often have endpoints that retrieve user info based on token to stay logged in OR eg. on social media site to see other users' profiles

HOW TO MODULARISE ROUTES INTO SEPARATE FILES IN FASTAPI USING 'ROUTERS':
Want to clean up code and make it more readable and maintainable so split Post/User routes into separate files
--> create a new file for each route eg. post.py and user.py
--> import router object into main.py and each of the route files ---> create a router object in each file and add route functions to the router object
in main.py: import files with router object defining paths --> then app.include_router(routefilename.router)
--> add the router object to the main FastAPI app object in main.py
**note :
There are several __init__.py files: one in each directory or subdirectory.
It indicates dir should be treated as a python package (that can be imported)
so subdirectories can be imported as modules ('sub'-modules)

NEXT --> how to group FASTAPI documentation into groups to organise readability/access of different route groups
add tag in the router object created in the router files

**------------AUTHENTICATION-------------**
1. Session-based Auth --> store user data in memory/DB/session(cookie) on BE server or API server to track user (logged in or not)
2. JWT based Auth --> 'stateless', self-contained - no user data stored on server. User data stored in token (encrypted) and sent to client. Client sends token with each req to server. Server decrypts token to verify user. JWT token can be stored in client FE in secure cookie or local storage/session storage.
JWT flow: Client sends login req (username+pw) to server API login route --> IF VALID client credentials are used to create JWT Token which is sent back to client --> Client stores token and it is sent with each req (in req HEADERS) to server --> Server decrypts token to verify token/user before sending response.
JWT Token made of 3 components: 
	1. HEADER (token type [JWT] + hashing algo [default HS256]), 
	2. PAYLOAD (data), 
	**NOTE - token itself is not encrypted so don't send sensitive data in payload eg. usually embed user id or user role. Too much data increases size of token/packet which wastes bandwidth unnecessarily (slows down reqs)
	3. SIGNATURE (need to create) by signing ==> HEADER + PAYLOAD [+ SECRET](special pw/key kept on server/API used to sign token) --> all get combined and hashed together using SECRET to create signature
	So Header, Payload and Signature get sent to client. Secret kept on server and used to verify signature of tokens sent in reqs
	SECRET is a key used to sign and verify tokens. ONLY SERVER SHOULD HAVE ACCESS TO IT.
	Server will know if token has been tampered, as signature will be different (eg. any modification to any part changes signature like changing payload data or the header)
	So more for ensuring data integrity, token info and verification rather than encrypting data.

*In this project using JWT Tokens for Auth:
User sends login req to API with username, pw. We verify with user-data stored in DB. However DB configured to store hashed password (hashing is only one way! so can't unhash to compare) therefore need to hash (using same hashing function) the password sent in req and compare with hashed password in DB.
If user valid then token sent back to client.

--create auth.py router (also created util function to hash password from req)
pip install python-jose[cryptography] -->to generate and verifty JWT token [cryptography] BE
*NOT USEDpip install passlib[bcrypt] --> to hash passwords bcrypt algo (need to create a passlib context to hash pw)

Once JWT Token setup is complete then able to protect endpoints by adding dependency (get_current_user: int =  Depends(oath2.get_current_user)) to other routes in function params to ensure that resource can only be accessed by authenticated/logged in users when they provide access JWT token.

POSTMAN - ADVANCED FEATURES 
Environment Variables - basically like using .env file. So you can easily switch between environments (that have different variables) eg. production, dev, test environments
once variables set use them in req by putting variable name {{}} and setting the environment in the top right corner of the Postman app (so for eg. you can {{URL}}/post easily switches URL between different environments without having to change the URL in each req)

Able to use code to automatically set an environment variable --> eg. access_token from login route
--> use code to extract token from response and set it as an environment variable (so can use it in other reqs)
--> in 'Tests' tab pm.environment.set("JWT", pm.response.json().access_token); then set {{JWT}} in Authorization tab
this allows for dynamic updating of environment variables

SETTING UP RELATIONSHIP BETWEEN POSTS-USERS tables
User --> Post (1 to many relationship) - 1 user can have many posts
need to create foreign key in Post table that references the id of the User table




