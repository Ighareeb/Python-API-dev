Create virtual environments to allow for different versions of the same project to be created, isolated from other project environments.
--> In terminal 'py -3 -m venv venv' to create a virtual environment called 'venv'
--> then make sure terminal is also using virtual env by connecting it to the activate.bat file in the venv folder 'venv\Scripts\activate.bat'

FastAPI is a modern, fast (high-performance), web framework for building APIs with Python 
uvicorn is a lightning-fast ASGI (async server gateway interface) server implementation, using uvloop and httptools. Supports async processing (efficiently handle multiple req concurrently); HTTP + Websockets (handle http + real-time 2-way traffic); enables interloperability between different frameworks and servers.
*FastAPI --> Autogenerates API documentation (2 ways to access: /docs or /redoc)


'decorator' is a design pattern in Python that allows adding new functionality to an existing object without modifying its structure. Functions are objects - in this scenario the 'app' object (FastAPI function) is wrapping the function for the route function. You can create functions and the use them as 'decorator' variables with the @ symbol to wrap/nest other functions and add/chain functionality to them.
You can add default status code to after route + use status.HTTP_###_action from fastapi responses module

TERMINAL [ uvicorn main:app --reload ] to start webserver (main = filename, app = FastAPI object name, --reeload = auto-reload server on file changes [dev env])

*The order of the route functions is important as FastAPI will match the first route function that matches the URL path. So if you have a route function that is more general and a route function that is more specific, the more specific route function should be placed first in the code.

Pydantic - Why Schema needed: 
Difficult to get valueswor from req body without knowing structure of data beforehand
Client can send whatever data they want
Data isnt getting validated.
Force client to send data in a standardised, specific format/schema that we expect.
APIs should be designed like this --> explicitly define what the data should look like so FE devs know what to send and BE devs know what to expect.
Pydantic models have methods that can be used on them eg. dict() to convert to dictionary, json() to convert to json, etc.

DATABASES:
Don't work or interact with DB directly --> use software DBMS to interact and send result back
For this project --> using PostgreSQL
Each instance of Postgres can be carved into into multiple separate/isolated DB
Postgres requires user to specify which DB to connect to 
pgAdmin = GUI tool to manage Postgres DBs
UNIQUE and NULL/NOT NULL --> eg. column constraints

--> *psycopg* is adapter for Python that allows interaction with Postgres DBs
https://www.psycopg.org/psycopg3/docs/basic/usage.html
Use psycopg db control structure --> cursor  to perform DB operations (execute queries, fetch results, etc) that can be added to route handling logic
!SQL injection attack - don't use f-strings for variables use %s + SQL library offers functionality to sanitise endpoints
need to commit staged changes --> when adding to DB (conn.commit())

For Python Apps(+other languages)  - Different ways to interact with DB
- example so far was using default Postgres driver/adaptor to send raw SQL commands to the DB
*--> A Popular method ORM (Object Relational Mapping) uses a layer of abstractions between code and DB so you can use Python code/objects/features to perform all DB ops (no SQL) [i.e. interact with ORM, which basically uses the drivers you would have employed if you were writing raw SQL, that will convert Python code to SQL commands] 
[SQLAlchemy very popular] - WHAT CAN YOU DO WITH ORMs (key features):
Instead of manually defining tables in postgres - define tables as Python classes/models
Query in Python code (no SQL necessary), chaining methods.
class Post(Base):
	__tablename__ = 'posts'
	id = Column(Integer, primary_key=True, index=True)
	title = Column(String, index=True, nullable=False)
	content = Column(String, nullable=False)
	published = Column(Boolean, default=False)

db.query(models.Post).filter(models.Post.id = id).first()

**to handle DB connect when using SQLAlchemy ORM, we need to create a database.py file in the app directory
-->installed SQLAlchemy and import required components to create DB and start session

*SQLAlchemy has the code to write Python (eg. define models) but doesn't 'actually know how to talk to the DB' ----> so need DB Driver (eg. psycopg)
*NOTE - when creating table from models - if table already exists no new table will be created - so if you modify table model you need to drop the table and recreate it
---> Normally use 'Alembiuc' to handle this - a migration tool that can initiailise dbs, handle changes to DB schema

DIFFERENCE BETWEEN Schema and Pydantic Model (WE NEED BOTH MODELS):
Pydantic (library) model --> BaseModel referred to as schema.  Define structure of req/res data. Validates structure and data types for fields + convert to/from JSON.
SQLAlchemy (library) model --> ORM Base model. Define columns/attributes + data types of DB tables. Used to interact (CRUD) with DB.
--> To use Res Models need to add response_model param to route function @app.method('/route', response_model=ModelName) - FastAPI will validate and convert response data to model schema 
(note for get all post need to use List[ModelName] as response_model + import List from typing module)

HANDLING USER REGISTRATION:
need to create model for user registration data (Pydantic model) + model for user data in DB (SQLAlchemy model)

hashing user password --> install passlib package + Bcrypt library (hashing algorithm)

# GET USER (by id) - can be used as part of auth process
# depending on how FE is set up eg. when using JWT (sent as cookies so won't know you are logged in) so APIs often have endpoints that retrieve user info based on token to stay logged in OR eg. on social media site to see other users' profiles